{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"volume","id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Cloud Cave: Light\n// Neo Mohsenvand\n// This work is heavily inspired by https://www.shadertoy.com/view/XslGRr and ideas from https://www.shadertoy.com/view/XdGXD3\n\n// =================================================================================\n//                                  CONFIGURATION\n// =================================================================================\n\n// --- QUALITY & METHOD SETTINGS ---\n#define LOOK 1           // 0: Sunset look, 1: Bright look\n#define NOISE_METHOD 1   // 0: 3D Tex, 1: 2D Tex (Hardware), 2: 2D Tex (Software)\n#define USE_LOD 1        // 1: Use Level of Detail for performance, 0: High quality only\nconst int   RENDER_STEPS = 150;  // Number of raymarch steps (Higher = better quality, slower)\nconst float DRAW_DIST    = 80.0; // Maximum distance to render\n\n// --- CAMERA & MOVEMENT ---\nconst float CAM_SPEED       = 2.5;  // Speed of flying through the tunnel\nconst float CAM_FOV         = 1.8;  // Field of View (1.5 = Standard/Narrow, higher = wide angle)\nconst float CAM_ROLL_AMP    = 0.2;  // How much the camera tilts side-to-side\nconst float CAM_ROLL_FREQ   = 0.1;  // How fast the camera tilts\nconst float CAM_LOOK_AHEAD  = 1.0;  // How far ahead on the path the camera looks\nconst float SUN_PATH_OFFSET = 15.0; // How far ahead the \"Sun\" is calculated (controls light direction)\n\n// --- TUNNEL GEOMETRY ---\nconst float TUNNEL_RADIUS   = 1.7;  // The radius of the empty space in the middle\nconst float PATH_AMP_X      = 2.5;  // Amplitude of the path curve (Left/Right)\nconst float PATH_FREQ_X     = 0.2;  // Frequency of the path curve (Left/Right)\nconst float PATH_AMP_Y      = 2.5;  // Amplitude of the path curve (Up/Down)\nconst float PATH_FREQ_Y     = 0.15; // Frequency of the path curve (Up/Down)\n\n// --- CLOUD SHAPE & VORTEX ---\nconst float VORTEX_SPEED    = 0.3;  // Speed of the cloud rotation around the center\nconst float VORTEX_TWIST    = 0.1;  // How much the clouds twist along the depth\nconst float NOISE_SCALE_BASE= 0.3;  // Scale of the base noise structure\nconst float NOISE_SCALE_DET = 0.7;  // Scale of the detail noise (Lower = Fluffier/Larger shapes)\nconst float CLOUD_DENSITY   = 3.0;  // Multiplier for cloud thickness/density\n\n// --- LIGHTING & COLORS ---\n// Note: Colors are RGB (0.0 to 1.0)\nconst vec3  BG_COLOR        = vec3(0.4, 0.5, 0.6);      // Base background color\nconst vec3  LIGHT_COLOR_1   = vec3(0.65, 0.65, 0.75);   // Ambient light color\nconst vec3  LIGHT_COLOR_2   = vec3(1.0, 1.0, 0.95);     // Direct sun light color\nconst vec3  CLOUD_BASE_COL  = vec3(0.9, 0.9, 1.0);      // Color of lit clouds\nconst vec3  CLOUD_SHADOW_COL= vec3(0.1, 0.1, 0.2);   // Color of deep cloud shadows (Contrast)\nconst float FOG_DENSITY     = 0.03;                     // Exponential fog density\n\n// --- SUN GLOW EFFECTS ---\nconst vec3  SUN_GLOW_COL    = vec3(1.0, 1.0, 1.0);      // Color of the outer sun glow\nconst float SUN_GLOW_POW    = 100.0;                     // Tightness of glow (Higher = smaller spot)\nconst vec3  SUN_CORE_COL    = vec3(1.0, 1.0, 1.0);      // Color of the sun center\nconst float SUN_CORE_POW    = 80.0;                     // Tightness of sun core\nconst vec3  SUN_GLARE_COL   = vec3(1.0, 0.8, 0.7);      // Color of glare over clouds\nconst float SUN_GLARE_POW   = 8.0;                      // Tightness of glare\n\n// =================================================================================\n//                               END CONFIGURATION\n// =================================================================================\n\n// --- PATH FUNCTION ---\nvec3 path(in float z)\n{\n    float t = z;\n    vec3 p = vec3(sin(t * PATH_FREQ_X) * PATH_AMP_X, \n                  cos(t * PATH_FREQ_Y) * PATH_AMP_Y, \n                  z);\n    return p;\n}\n\n// --- NOISE FUNCTIONS ---\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    // NOISE_METHOD 1: Two 2D texture lookups\n    vec2 uv = (p.xy + vec2(37.0, 239.0) * p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z) * 2.0 - 1.0;  \n}\n\n// --- MAP FUNCTION ---\nfloat map(in vec3 p, int oct)\n{\n    // 1. Get position relative to the camera path\n    vec3 pPath = path(p.z);\n    vec3 relP = p - pPath;\n    \n    // 2. Base Tunnel Shape\n    float tunnelDist = length(relP.xy);\n    \n    // 3. Noise Generation (Clouds) with VORTEX EFFECT\n    \n    // Calculate rotation angle based on Time (spin) and Depth (twist)\n    float angle = -iTime * VORTEX_SPEED + p.z * VORTEX_TWIST;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    // Rotate the XY coordinates relative to the path center\n    vec2 twistedXY = rot * relP.xy;\n    \n    // Construct the noise coordinate system 'q'\n    vec3 q = vec3(twistedXY, p.z - iTime * 0.5);\n    \n    // Initial large scale noise (Base shape)\n    float g = 0.5 + 0.5 * noise(q * NOISE_SCALE_BASE);\n    \n    float f;\n    // Detail noise\n    f  = 0.50000 * noise(q * NOISE_SCALE_DET); \n    \n#if USE_LOD==1\n    if (oct >= 2) \n#endif\n        f += 0.25000 * noise(q * NOISE_SCALE_DET * 2.25); // Scaling approximation based on previous logic\n        \n#if USE_LOD==1\n    if (oct >= 3)\n#endif\n        f += 0.12500 * noise(q * NOISE_SCALE_DET * 5.0); \n        \n#if USE_LOD==1\n    if (oct >= 4)\n#endif\n        f += 0.06250 * noise(q * NOISE_SCALE_DET * 10.0); \n    \n    f = mix(f * 0.1 - 0.5, f, g * g);\n    \n    // 4. Combine Tunnel + Noise\n    float density = (tunnelDist - TUNNEL_RADIUS) + (f * CLOUD_DENSITY); \n    \n    return clamp(density, 0.0, 1.0);\n}\n\nconst int kDiv = 1; \n\nvec4 raymarch(in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px, in vec3 sundir)\n{\n    // dithered near distance\n    float t = 0.0 + 0.1 * texelFetch(iChannel1, px & ivec2(1023), 0).x;\n    \n    vec4 sum = vec4(0.0);\n    \n    // Standard step count\n    for (int i = 0; i < RENDER_STEPS * kDiv; i++) \n    {\n       // Step size \n       float dt = max(0.1, 0.07 * t / float(kDiv));\n\n       // LOD calculation\n#if USE_LOD==0\n       const int oct = 5;\n#else\n       int oct = 5 - int(log2(1.0 + t * 0.5)); \n#endif\n       \n       // sample cloud\n       vec3 pos = ro + t * rd;\n       float den = map(pos, oct);\n       \n       if (den > 0.01) // if inside\n       {\n           // do lighting\n           float dif = clamp((den - map(pos + 0.6 * sundir, oct)) / 0.5, 0.0, 1.0);\n           \n           // Light Colors\n           vec3  lin = LIGHT_COLOR_1 * 1.1 + 0.8 * LIGHT_COLOR_2 * dif;\n           \n           // Cloud Color Mixing\n           vec4  col = vec4(mix(CLOUD_BASE_COL, CLOUD_SHADOW_COL, den), den);\n           \n           col.xyz *= lin;\n           \n           // Fog\n           col.xyz = mix(col.xyz, bgcol, 1.0 - exp2(-FOG_DENSITY * t));\n           \n           col.w    = min(col.w * 8.0 * dt, 1.0);\n           col.rgb *= col.a;\n           sum += col * (1.0 - sum.a);\n       }\n       \n       t += dt;\n       \n       if (t > DRAW_DIST || sum.a > 0.99) break;\n    }\n\n    return clamp(sum, 0.0, 1.0);\n}\n\nvec4 render(in vec3 ro, in vec3 rd, in ivec2 px, in float t)\n{\n    // Calculate sun direction based on path offset\n    vec3 sunPos = path(t + SUN_PATH_OFFSET);\n    vec3 sundir = normalize(sunPos - ro);\n\n    // Sun calculation\n    float sun = clamp(dot(sundir, rd), 0.0, 1.0);\n\n    // Background gradient\n    vec3 col = BG_COLOR;\n    \n    // Add \"Light at end of tunnel\" glow\n    col += 0.4 * SUN_GLOW_COL * pow(sun, SUN_GLOW_POW);\n    \n    // Core of the sun\n    col += 1.0 * SUN_CORE_COL * pow(sun, SUN_CORE_POW);\n\n    // clouds    \n    vec4 res = raymarch(ro, rd, col, px, sundir);\n    col = col * (1.0 - res.w) + res.xyz;\n    \n    // sun glare over clouds\n    col += 0.2 * SUN_GLARE_COL * pow(sun, SUN_GLARE_POW);\n\n    // tonemap\n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.4545)); \n \n    return vec4(col, 1.0);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float t = iTime * CAM_SPEED; \n    \n    // Current position on path\n    vec3 ro = path(t);\n    // Look ahead on the path\n    vec3 ta = path(t + CAM_LOOK_AHEAD);\n    \n    float roll = CAM_ROLL_AMP * sin(t * CAM_ROLL_FREQ); \n\n    mat3 ca = setCamera(ro, ta, roll);\n    \n    vec3 rd = ca * normalize(vec3(p.xy, CAM_FOV)); \n    \n    // Pass 't' to render so it can calculate the sun position ahead\n    fragColor = render(ro, rd, ivec2(fragCoord - 0.5), t);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Wc3yRl","date":"1763941491","viewed":19,"name":"Cloud Cave: Light","username":"neovand","description":"Forked from https://www.shadertoy.com/view/XslGRr and combined ideas from https://www.shadertoy.com/view/XdGXD3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","volumetric","lod","vr"],"hasliked":0,"parentid":"","parentname":""}}